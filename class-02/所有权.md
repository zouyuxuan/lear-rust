## 动态数据和静态数据存储
基础类型大小确定，数据存放在栈上
动态数据类型默认放在堆上，在栈上局部变量指向堆

## rust所有权规则
1、Rust中,每一个值(资源)都有一个所有者;
2、任何一个时刻,一个值只有一个所有者;
3、当所有者所在作用域结束的时候,值会被释放掉。
## 变量作用域
变量的作用域,就是变量有效(valid)的那个区间。在Rust中,简单来说就是在一对`花括号`括起的里面部分中,从变量创建时开始,到花括号结束的地方
```
fn main(){
    {
        let s = String::from("hello");
    }
    println!("{}",s); // s离开作用域
}
```
## 可变引用和不可变引用
引用包含不可变引用和可变引用
&x 对变量x的不可变引用
```
let s = String::from("hello");
s.push('a'); //报错cannot borrow as mutable
println!("{}",s); 
```
&mut x 对变量x的可变引用
```
let mut s = String::from("hello");
s.push('a'); 
```
## rust借用规则
1、唯一性（Uniqueness）：在任何给定的时间点，只能有一个可变引用（mutable reference）或多个不可变引用（immutable reference）指向同一块内存。这个规则确保了数据的安全性，防止数据竞争。
```
let mut x = 5;
let y1 = &mut x; // 可变引用
let y2 = &mut x; // 编译错误，同时存在多个可变引用
```

2、不可变性（Immutability）：当数据被不可变引用时，不能通过这些引用修改数据。这个规则确保了数据的可靠性和一致性。
```
let mut x = 5;
let y = &x; // 不可变引用
*y = 10; // 编译错误，不能通过不可变引用修改数据
```
3、可变性（Mutability）：只有在没有其他引用的情况下，才能创建可变引用。这个规则确保了在修改数据时的独占访问权。

4、生命周期（Lifetime）：Rust使用生命周期来跟踪引用的有效范围，以确保引用不会超出其指向的数据的生命周期。这个规则确保了引用的有效性和安全性。